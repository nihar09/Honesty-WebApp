<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
     <link rel="stylesheet" type="text/css" href="bootstrap.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Montserrat|Open+Sans" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.0.2/anime.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
  <title>Word Search</title>
  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">

    <script type="text/javascript">
      var score=0;
      function timeout()
      {
        //var minute=Math.floor((timeLeft-(hours*60*60))/60);
        var minute=Math.floor(timeLeft/60);
        var second=timeLeft%60;
        //var hrs=checktime(hours);
        var mint=checktime(minute);
        var sec=checktime(second);
        if(timeLeft<0)
        {
            clearTimeout(tm);
            document.getElementById("img1").hidden = true;
            document.getElementById("img2").hidden = true;
            
            document.getElementById("solve").hidden = true;
            document.getElementById("puzzle").innerHTML = "";
            document.getElementById("words").innerHTML = "";
            document.getElementById("totscore").innerHTML = "Total Correct Answers " + score;
            document.getElementById("totcoins").innerHTML = "Total Coins Achieved " + score;
            document.getElementById("coins").hidden = false;
            document.getElementById("drop").play();
            document.getElementById("my_audio").pause();
            document.getElementById("my_end").play();
            delay(5000);
            document.getElementById("my_end").pause();
        }
        else
        {
            document.getElementById("time").innerHTML=mint+":"+sec;
        }
        timeLeft--;
        var tm=setTimeout(function(){timeout()},1000);
      }
      function checktime(msg)
      {
        if(msg<10)
        {
            msg="0"+msg;
        }
        return msg;
      }
      </script>  


      <style>
body {
  background-color: #fcf7ff;
}

.puzzleWrap {
  width: 850px;
  margin: 50px auto 0;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

p {
  font: 22pt sans-serif;
  margin: 20px 20px 0px 45px;
  color: #6891ad;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

/**
* Styles for the puzzle
*/
#puzzle {
  padding: 20px;
  text-align: center;
  width: 500px;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

#puzzle div {
  width: 100%;
  margin: 0 auto;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

/* style for each square in the puzzle */
#puzzle .puzzleSquare {
  height: 30px;
  width: 30px;
  text-transform: uppercase;
  background-color: transparent;
  border: 0;
  font: 1em sans-serif;
  color: #9e66a0;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

button::-moz-focus-inner {
  border: none;
  outline: none;
  font-size: 14pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

/* indicates when a square has been selected */
#puzzle .selected {
  color: #000000;
  outline: none;
}
#puzzle .selected:focus {
  border: none;
}

/* indicates that the square is part of a word that has been found */
#puzzle .found {
  color: #000000;
}

#puzzle .solved {
  color: #000000;
}

/* indicates that all words have been found */
#puzzle .complete {
  background-color: #ffbcfd;

}

/**
* Styles for the word list
*/
#words {
  width: 250px;
  color: #e00463;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

#words ul {
  list-style-type: none;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

#words li {
  padding: 0 0 7px;
  font: 1em sans-serif;
  display: inline-block;
  float: left;
  width: 100px;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

/* indicates that the word has been found */
#words .wordFound {
  text-decoration: line-through;
  color: #000000;
  font-size: 13.5pt ; 
  font-family: Comic Sans MS, Comic Sans, cursive;
}

/**
* Styles for the button
*/
#solve {
  margin: 30px 30px 0 40px;
  background: transparent;
  color: #ee5426;
  padding: 10px 20px;
  border: 2px solid #ee5426;
  border-radius: 25px;
  opacity: .5;
  transition: opacity .25s ease-in;
}
#solve:hover, #solve.gameSolved {
  opacity: 1;
}

.ml2 {
  font-weight: bold;
  font-size: 35pt;
}

.ml2 .letter {
  display: inline-block;
  line-height: 1em;
  font-size: 35pt;
}
div.angrytext {
 font-size:70px;
 font-weight:bold;
 color:#4794D3;
 width:300px;
 margin:90px auto;

 -webkit-animation: alert 2s linear 0s infinite normal ;
 animation: alert 2s linear 0s infinite normal ;
}

@-webkit-keyframes alert {
  0%{
  -webkit-transform: translateX(0);
  transform: translateX(0);
  }
  5%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  10%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  15%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  20%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  25%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  30%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  35%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  40%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  45%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  50%{
  -webkit-transform: translateX(0);
  transform: translateX(0);
  }
}

@keyframes alert {
  0%{
  -ms-transform: translateX(0);
  transform: translateX(0);
  }
  5%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  10%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  15%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  20%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  25%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  30%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  35%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  40%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  45%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  50%{
  -ms-transform: translateX(0);
  transform: translateX(0);
  }
}

div.angrytime {
 -webkit-animation: alert 2s linear 0s infinite normal ;
 animation: alert 2s linear 0s infinite normal ;
}

@-webkit-keyframes alert {
  0%{
  -webkit-transform: translateX(0);
  transform: translateX(0);
  }
  5%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  10%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  15%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  20%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  25%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  30%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  35%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  40%{
  -webkit-transform: translateX(10px);
  transform: translateX(10px);
  }
  45%{
  -webkit-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  50%{
  -webkit-transform: translateX(0);
  transform: translateX(0);
  }
}

@keyframes alert {
  0%{
  -ms-transform: translateX(0);
  transform: translateX(0);
  }
  5%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  10%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  15%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  20%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  25%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  30%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  35%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  40%{
  -ms-transform: translateX(10px);
  transform: translateX(10px);
  }
  45%{
  -ms-transform: translateX(-10px);
  transform: translateX(-10px);
  }
  50%{
  -ms-transform: translateX(0);
  transform: translateX(0);
  }
}
      </style>

  
</head>

<body>
<audio src="Fast-clock-ticking-sound-effect.mp3" id="my_audio" loop="loop"></audio>
  <audio src="Train Horn Low-SoundBible.com-1744689113.mp3" id="my_end"></audio>
  <audio src="coindrop.mp3" id="drop" loop="loop"></audio>
  <script type="text/javascript">
    window.onload=function(){
      document.getElementById("time").innerHTML = timeout();
      var aud = document.getElementById("my_audio").play();
    }
  </script>
 <div class="d-flex justify-content-center bg-secondary mb-3">
<img src="Logo.png" width="700px" height="700px" style="position: fixed; margin: 0; z-index: -1; opacity: 0.05">
</div>

  <script type="text/javascript">
                var timeLeft=8*60;
            </script>

           <div class='container angrytext' style="margin-right: -55%; margin-top: -10px; position: absolute; z-index: -1"><img src="clock.png" width="150px" height="150px"></div>
    <h3><div class="container angrytime" id="time" style="margin-top: 40px; margin-left: 45px; float: left; font-size: 18pt; font-weight: normal;">Timeout</div></h3><br>
  <h3 id="scoring" style="font-size: 18pt ; font-family: Comic Sans MS, Comic Sans, cursive; color: #BA55D3; float: right;">Your Score is 0</h3><br><br><br><br><br>
<center><h2 id="totscore" style="font-family: Comic Sans MS, Comic Sans, cursive; font-weight: bold; color: #BA55D3"></h2></center>
<center><h2 id="totcoins" style="font-family: Comic Sans MS, Comic Sans, cursive; font-weight: bold; color: #BA55D3"></h2></center>
<center><img src="coins.gif" id="coins" hidden="true" width="200px" height="200px"></center>
<h1 class="ml2" id="completion" style="text-align: center; font-family: Comic Sans MS, Comic Sans, cursive;"></h1>
  <div class="container" align="center">
    <img src="party1.gif" id="part1" hidden="true" width="300px" height="400px">
    <img src="good job.gif" id="goodjob" hidden="true" width="300px" height="400px">
    <img src="party1.gif" id="part2" hidden="true" width="300px" height="400px">
  </div>
<center><img src="honesty_wordsearch.png" width="55%" height="10%"></center><br><br><br><br><br>
<div class="puzzleWrap">
  
  <img src="down.png" id="img1" style="top: 60%; left: 20%; position: absolute; border-radius: 10px;" width="300px" height="350px">
  
  <img src="up.png" id="img2" style="top: 41%; right: 23%; position: absolute; border-radius: 10px;" width="300px" height="350px">
  <center><div id='words' style="font-size: 13.5pt ; font-family: Comic Sans MS, Comic Sans, cursive;"></center><br><br><br><br><br><br><br><br><br><br><br><br>
  <center><div id='puzzle' style="font-size: 13.5pt ; font-family: Comic Sans MS, Comic Sans, cursive;"></div></center>
  
    <center><button type="button" id="solve" style="font-family: Comic Sans MS, Comic Sans, cursive;" onclick="show()">I give up. Show me the answers rather!</button></center>
    <script type="text/javascript">
     function show()
     {
        document.getElementById("totscore").innerHTML = "Total Correct Answers " + score;
            document.getElementById("totcoins").innerHTML = "Total Coins Achieved " + score;
            document.getElementById("coins").hidden = false;
            document.getElementById("my_audio").pause();
      setTimeout(function(){ 
      document.getElementById("drop").play(); 
      }, 1000)
     }
    </script>
  </div>
  <br>
  
  
</div>
  <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js'></script>

  

    <script type="text/javascript">


(function () {

  'use strict';

  
  var WordFind = function () {

    // Letters used to fill blank spots in the puzzle
    var letters = 'abcdefghijklmnoprstuvwy';

    

    // The list of all the possible orientations
    var allOrientations = ['horizontal','horizontalBack','vertical','verticalUp',
                           'diagonal','diagonalUp','diagonalBack','diagonalUpBack'];

    // The definition of the orientation, calculates the next square given a
    // starting square (x,y) and distance (i) from that square.
    var orientations = {
      horizontal:     function(x,y,i) { return {x: x+i, y: y  }; },
      horizontalBack: function(x,y,i) { return {x: x-i, y: y  }; },
      vertical:       function(x,y,i) { return {x: x,   y: y+i}; },
      verticalUp:     function(x,y,i) { return {x: x,   y: y-i}; },
      diagonal:       function(x,y,i) { return {x: x+i, y: y+i}; },
      diagonalBack:   function(x,y,i) { return {x: x-i, y: y+i}; },
      diagonalUp:     function(x,y,i) { return {x: x+i, y: y-i}; },
      diagonalUpBack: function(x,y,i) { return {x: x-i, y: y-i}; }
    };

    // Determines if an orientation is possible given the starting square (x,y),
    // the height (h) and width (w) of the puzzle, and the length of the word (l).
    // Returns true if the word will fit starting at the square provided using
    // the specified orientation.
    var checkOrientations = {
      horizontal:     function(x,y,h,w,l) { return w >= x + l; },
      horizontalBack: function(x,y,h,w,l) { return x + 1 >= l; },
      vertical:       function(x,y,h,w,l) { return h >= y + l; },
      verticalUp:     function(x,y,h,w,l) { return y + 1 >= l; },
      diagonal:       function(x,y,h,w,l) { return (w >= x + l) && (h >= y + l); },
      diagonalBack:   function(x,y,h,w,l) { return (x + 1 >= l) && (h >= y + l); },
      diagonalUp:     function(x,y,h,w,l) { return (w >= x + l) && (y + 1 >= l); },
      diagonalUpBack: function(x,y,h,w,l) { return (x + 1 >= l) && (y + 1 >= l); }
    };

    // Determines the next possible valid square given the square (x,y) was ]
    // invalid and a word lenght of (l).  This greatly reduces the number of
    // squares that must be checked. Returning {x: x+1, y: y} will always work
    // but will not be optimal.
    var skipOrientations = {
      horizontal:     function(x,y,l) { return {x: 0,   y: y+1  }; },
      horizontalBack: function(x,y,l) { return {x: l-1, y: y    }; },
      vertical:       function(x,y,l) { return {x: 0,   y: y+100}; },
      verticalUp:     function(x,y,l) { return {x: 0,   y: l-1  }; },
      diagonal:       function(x,y,l) { return {x: 0,   y: y+1  }; },
      diagonalBack:   function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y    }; },
      diagonalUp:     function(x,y,l) { return {x: 0,   y: y<l-1?l-1:y+1  }; },
      diagonalUpBack: function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y  }; }
    };

   
    var fillPuzzle = function (words, options) {

      var puzzle = [], i, j, len;
      console.log('options = ', options);

      // initialize the puzzle with blanks
      for (i = 0; i < options.height; i++) {
        puzzle.push([]);
        for (j = 0; j < options.width; j++) {
          puzzle[i].push('');
        }
      }

      // add each word into the puzzle one at a time
      for (i = 0, len = words.length; i < len; i++) {
        if (!placeWordInPuzzle(puzzle, options, words[i])) {
          // if a word didn't fit in the puzzle, give up
          return null;
        }
      }

      // return the puzzle
      return puzzle;
    };

    
    var placeWordInPuzzle = function (puzzle, options, word) {

      // find all of the best locations where this word would fit
      var locations = findBestLocations(puzzle, options, word);

      if (locations.length === 0) {
        return false;
      }

      // select a location at random and place the word there
      var sel = locations[Math.floor(Math.random() * locations.length)];
      placeWord(puzzle, word, sel.x, sel.y, orientations[sel.orientation]);

      return true;
    };

    
    var findBestLocations = function (puzzle, options, word) {

      var locations = [],
          height = options.height,
          width = options.width,
          wordLength = word.length,
          maxOverlap = 0; // we'll start looking at overlap = 0

      // loop through all of the possible orientations at this position
      for (var k = 0, len = options.orientations.length; k < len; k++) {
        
        var orientation = options.orientations[k],
            check = checkOrientations[orientation],
            next = orientations[orientation],
            skipTo = skipOrientations[orientation],
            x = 0, y = 0;

        // loop through every position on the board
        while( y < height ) {

          // see if this orientation is even possible at this location
          if (check(x, y, height, width, wordLength)) {

            // determine if the word fits at the current position
            var overlap = calcOverlap(word, puzzle, x, y, next);

            // if the overlap was bigger than previous overlaps that we've seen
            if (overlap >= maxOverlap || (!options.preferOverlap && overlap > -1)) {
              maxOverlap = overlap;
              locations.push({x: x, y: y, orientation: orientation, overlap: overlap});
            }

            x++;
            if (x >= width) {
              x = 0;
              y++;
            }
          }
          else {
            // if current cell is invalid, then skip to the next cell where
            // this orientation is possible. this greatly reduces the number
            // of checks that we have to do overall
            var nextPossible = skipTo(x,y,wordLength);
            x = nextPossible.x;
            y = nextPossible.y;
          }

        }
      }

      // finally prune down all of the possible locations we found by
      // only using the ones with the maximum overlap that we calculated
      return options.preferOverlap ?
             pruneLocations(locations, maxOverlap) :
             locations;
    };

    
    var calcOverlap = function (word, puzzle, x, y, fnGetSquare) {
      var overlap = 0;

      // traverse the squares to determine if the word fits
      for (var i = 0, len = word.length; i < len; i++) {

        var next = fnGetSquare(x, y, i),
            square = puzzle[next.y][next.x];
        
        // if the puzzle square already contains the letter we
        // are looking for, then count it as an overlap square
        if (square === word[i]) {
          overlap++;
        }
        // if it contains a different letter, than our word doesn't fit
        // here, return -1
        else if (square !== '' ) {
          return -1;
        }
      }

      // if the entire word is overlapping, skip it to ensure words aren't
      // hidden in other words
      return overlap;
    };

    
    var pruneLocations = function (locations, overlap) {

      var pruned = [];
      for(var i = 0, len = locations.length; i < len; i++) {
        if (locations[i].overlap >= overlap) {
          pruned.push(locations[i]);
        }
      }

      return pruned;
    };

    
    var placeWord = function (puzzle, word, x, y, fnGetSquare) {
      for (var i = 0, len = word.length; i < len; i++) {
        var next = fnGetSquare(x, y, i);
        puzzle[next.y][next.x] = word[i];
      }
    };

    return {

      
      validOrientations: allOrientations,

      
      orientations: orientations,

      
      newPuzzle: function(words, settings) {
        var wordList, puzzle, attempts = 0, opts = settings || {};

        console.log('newPuzzle() :: settings = ', settings);
        
        // copy and sort the words by length, inserting words into the puzzle
        // from longest to shortest works out the best
        wordList = words.slice(0).sort( function (a,b) {
          return (a.length < b.length) ? 1 : 0;
        });
        
        // initialize the options
        var options = {
          height:       opts.height || wordList[0].length,
          width:        opts.width || wordList[0].length,
          orientations: opts.orientations || allOrientations,
          fillBlanks:   opts.fillBlanks !== undefined ? opts.fillBlanks : true,
          maxAttempts:  opts.maxAttempts || 3,
          preferOverlap: opts.preferOverlap !== undefined ? opts.preferOverlap : true
        };

        // add the words to the puzzle
        // since puzzles are random, attempt to create a valid one up to
        // maxAttempts and then increase the puzzle size and try again
        while (!puzzle) {
          while (!puzzle && attempts++ < options.maxAttempts) {
            puzzle = fillPuzzle(wordList, options);
          }

          if (!puzzle) {
            options.height++;
            options.width++;
            attempts = 0;
          }
        }

        // fill in empty spaces with random letters
        if (options.fillBlanks) {
          this.fillBlanks(puzzle, options);
        }

        return puzzle;
      },

      
      fillBlanks: function (puzzle) {
        for (var i = 0, height = puzzle.length; i < height; i++) {
          var row = puzzle[i];
          for (var j = 0, width = row.length; j < width; j++) {

            if (!puzzle[i][j]) {
              var randomLetter = Math.floor(Math.random() * letters.length);
              puzzle[i][j] = letters[randomLetter];
            }
          }
        }
      },

      /**
      * Returns the starting location and orientation of the specified words
      * within the puzzle. Any words that are not found are returned in the
      * notFound array.
      *
      * Returns
      *   x position of start of word
      *   y position of start of word
      *   orientation of word
      *   word
      *   overlap (always equal to word.length)
      *
      * @param {[[String]]} puzzle: The current state of the puzzle
      * @param {[String]} words: The list of words to find
      * @api public
      */
      solve: function (puzzle, words) {
        var options = {
                        height:       puzzle.length,
                        width:        puzzle[0].length,
                        orientations: allOrientations,
                        preferOverlap: true
                      },
            found = [],
            notFound = [];

        for(var i = 0, len = words.length; i < len; i++) {
          var word = words[i],
              locations = findBestLocations(puzzle, options, word);

          if (locations.length > 0 && locations[0].overlap === word.length) {
            locations[0].word = word;
            found.push(locations[0]);
          }
          else {
            notFound.push(word);
          }
        }

        return { found: found, notFound: notFound };
      },

      /**
      * Outputs a puzzle to the console, useful for debugging.
      * Returns a formatted string representing the puzzle.
      *
      * @param {[[String]]} puzzle: The current state of the puzzle
      * @api public
      */
      print: function (puzzle) {
        var puzzleString = '';
        for (var i = 0, height = puzzle.length; i < height; i++) {
          var row = puzzle[i];
          for (var j = 0, width = row.length; j < width; j++) {
            puzzleString += (row[j] === '' ? ' ' : row[j]) + ' ';
          }
          puzzleString += '\n';
        }

        console.log(puzzleString);
        return puzzleString;
      }
    };
  };

  /**
  * Allow library to be used within both the browser and node.js
  */
  var root = typeof exports !== "undefined" && exports !== null ? exports : window;
  root.wordfind = WordFind();

}).call(this);



(function (document, $, wordfind) {

  'use strict';

  
  var WordFindGame = function() {

    // List of words for this game
    var wordList;

    /**
    * Draws the puzzle by inserting rows of buttons into el.
    *
    * @param {String} el: The jQuery element to write the puzzle to
    * @param {[[String]]} puzzle: The puzzle to draw
    */
    var drawPuzzle = function (el, puzzle) {
      console.log('drawPuzzle()');
      var output = '';
      // for each row in the puzzle
      for (var i = 0, height = puzzle.length; i < height; i++) {
        // append a div to represent a row in the puzzle
        var row = puzzle[i];
        output += '<div>';
        // for each element in that row
        for (var j = 0, width = row.length; j < width; j++) {
            // append our button with the appropriate class
            output += '<button class="puzzleSquare" x="' + j + '" y="' + i + '">';
            output += row[j] || '&nbsp;';
            output += '</button>';
        }
        // close our div that represents a row
        output += '</div>';
      }

      $(el).html(output);
    };

    
    var drawWords = function (el, words) {
      
      var output = '<ul>';
      for (var i = 0, len = words.length; i < len; i++) {
        var word = words[i];
        output += '<li class="word ' + word + '">' + word;
      }
      output += '</ul>';

      $(el).prepend(output);
    };


    /**
    * Game play events.
    *
    * The following events handle the turns, word selection, word finding, and
    * game end.
    *
    */

    // Game state
    var startSquare, selectedSquares = [], curOrientation, curWord = '';

    /**
    * Event that handles mouse down on a new square. Initializes the game state
    * to the letter that was selected.
    *
    */
    var startTurn = function () {
      $(this).addClass('selected');
      startSquare = this;
      selectedSquares.push(this);
      curWord = $(this).text();
    };



    /**
    * Event that handles mouse over on a new square. Ensures that the new square
    * is adjacent to the previous square and the new square is along the path
    * of an actual word.
    *
    */
    var select = function (target) {
      // if the user hasn't started a word yet, just return
      if (!startSquare) {
        return;
      }

      // if the new square is actually the previous square, just return
      var lastSquare = selectedSquares[selectedSquares.length-1];
      if (lastSquare == target) {
        return;
      }

      // see if the user backed up and correct the selectedSquares state if
      // they did
      var backTo;
      for (var i = 0, len = selectedSquares.length; i < len; i++) {
        if (selectedSquares[i] == target) {
          backTo = i+1;
          break;
        }
      }

      while (backTo < selectedSquares.length) {
        $(selectedSquares[selectedSquares.length-1]).removeClass('selected');
        selectedSquares.splice(backTo,1);
        curWord = curWord.substr(0, curWord.length-1);
      }


      // see if this is just a new orientation from the first square
      // this is needed to make selecting diagonal words easier
      var newOrientation = calcOrientation(
          $(startSquare).attr('x')-0,
          $(startSquare).attr('y')-0,
          $(target).attr('x')-0,
          $(target).attr('y')-0
          );

      if (newOrientation) {
        selectedSquares = [startSquare];
        curWord = $(startSquare).text();
        if (lastSquare !== startSquare) {
          $(lastSquare).removeClass('selected');
          lastSquare = startSquare;
        }
        curOrientation = newOrientation;
      }

      // see if the move is along the same orientation as the last move
      var orientation = calcOrientation(
          $(lastSquare).attr('x')-0,
          $(lastSquare).attr('y')-0,
          $(target).attr('x')-0,
          $(target).attr('y')-0
          );

      // if the new square isn't along a valid orientation, just ignore it.
      // this makes selecting diagonal words less frustrating
      if (!orientation) {
        return;
      }

      // finally, if there was no previous orientation or this move is along
      // the same orientation as the last move then play the move
      if (!curOrientation || curOrientation === orientation) {
        curOrientation = orientation;
        playTurn(target);
      }

    };
    
    var touchMove = function(e) {
      var xPos = e.originalEvent.touches[0].pageX;
      var yPos = e.originalEvent.touches[0].pageY;
      var targetElement = document.elementFromPoint(xPos, yPos);
      select(targetElement)
    };
    
    var mouseMove = function() { 
      select(this);
    };

    /**
    * Updates the game state when the previous selection was valid.
    *
    * @param {el} square: The jQuery element that was played
    */
    var playTurn = function (square) {

      // make sure we are still forming a valid word
      for (var i = 0, len = wordList.length; i < len; i++) {
        if (wordList[i].indexOf(curWord + $(square).text()) === 0) {
          $(square).addClass('selected');
          selectedSquares.push(square);
          curWord += $(square).text();
          break;
        }
      }
    };

    /**
    * Event that handles mouse up on a square. Checks to see if a valid word
    * was created and updates the class of the letters and word if it was. Then
    * resets the game state to start a new word.
    *
    */
    //var score=0;
    var endTurn = function () {

      // see if we formed a valid word
      for (var i = 0, len = wordList.length; i < len; i++) {
        
        if (wordList[i] === curWord) {
          $('.selected').addClass('found');
          wordList.splice(i,1);
          $('.' + curWord).addClass('wordFound');
          score++;
          document.getElementById("scoring").innerHTML = "Your Score is " + score;
        }

        if (wordList.length === 0) {
          $('.puzzleSquare').addClass('complete');
          document.getElementById("completion").innerHTML = "Congratulations You Solved the Puzzle";
          document.getElementById("img1").hidden = true;
          document.getElementById("img2").hidden = true;
          document.getElementById("part1").hidden = false;
            document.getElementById("goodjob").hidden = false;
            document.getElementById("part2").hidden = false;
            $('.ml2').each(function(){
        $(this).html($(this).text().replace(/([^\x00-\x80]|\w)/g, "<span class='letter'>$&</span>"));
      });

      anime.timeline({loop: true})
        .add({
        targets: '.ml2 .letter',
        scale: [4,1],
        opacity: [0,1],
        translateZ: 0,
        easing: "easeOutExpo",
        duration: 950,
        delay: function(el, i) {
          return 70*i;
        }
        }).add({
        targets: '.ml2',
        opacity: 0,
        duration: 1000,
        easing: "easeOutExpo",
        delay: 1000
        });
          document.getElementById("totscore").innerHTML = "Total Correct Answers " + score;
          document.getElementById("totcoins").innerHTML = "Total Coins Achieved " + score;
              document.getElementById("coins").hidden = false;
          document.getElementById("my_audio").pause();
      setTimeout(function(){ 
      document.getElementById("drop").play(); 
      }, 1000)
          // Wrap every letter in a span
      
      $('.ml2').each(function(){
        $(this).html($(this).text().replace(/([^\x00-\x80]|\w)/g, "<span class='letter'>$&</span>"));
      });

      anime.timeline({loop: true})
        .add({
        targets: '.ml2 .letter',
        scale: [4,1],
        opacity: [0,1],
        translateZ: 0,
        easing: "easeOutExpo",
        duration: 950,
        delay: function(el, i) {
          return 70*i;
        }
        }).add({
        targets: '.ml2',
        opacity: 0,
        duration: 1000,
        easing: "easeOutExpo",
        delay: 1000
        });




        }
      }

      // reset the turn
      $('.selected').removeClass('selected');
      startSquare = null;
      selectedSquares = [];
      curWord = '';
      curOrientation = null;
    };

    /**
    * Given two points, ensure that they are adjacent and determine what
    * orientation the second point is relative to the first
    *
    * @param {int} x1: The x coordinate of the first point
    * @param {int} y1: The y coordinate of the first point
    * @param {int} x2: The x coordinate of the second point
    * @param {int} y2: The y coordinate of the second point
    */
    var calcOrientation = function (x1, y1, x2, y2) {

      for (var orientation in wordfind.orientations) {
        var nextFn = wordfind.orientations[orientation];
        var nextPos = nextFn(x1, y1, 1);

        if (nextPos.x === x2 && nextPos.y === y2) {
          return orientation;
        }
      }

      return null;
    };

    return {

      /**
      * Creates a new word find game and draws the board and words.
      *
      * Returns the puzzle that was created.
      *
      * @param {[String]} words: The words to add to the puzzle
      * @param {String} puzzleEl: Selector to use when inserting the puzzle
      * @param {String} wordsEl: Selector to use when inserting the word list
      * @param {Options} options: WordFind options to use when creating the puzzle
      */
      create: function(words, puzzleEl, wordsEl, options) {
        
        wordList = words.slice(0).sort();

        var puzzle = wordfind.newPuzzle(words, options);

         console.log('puzzle = ', puzzle);
        
        // draw out all of the words
        drawPuzzle(puzzleEl, puzzle);
        drawWords(wordsEl, wordList);

        // attach events to the buttons
        // optimistically add events for windows 8 touch
        if (window.navigator.msPointerEnabled) {
          $('.puzzleSquare').on('MSPointerDown', startTurn);
          $('.puzzleSquare').on('MSPointerOver', select);
          $('.puzzleSquare').on('MSPointerUp', endTurn);
        }
        else {
          $('.puzzleSquare').mousedown(startTurn);
          $('.puzzleSquare').mouseenter(mouseMove);
          $('.puzzleSquare').mouseup(endTurn);
          $('.puzzleSquare').on("touchstart", startTurn);
          $('.puzzleSquare').on("touchmove", touchMove);
          $('.puzzleSquare').on("touchend", endTurn);
        }

        return puzzle;
      },

      /**
      * Solves an existing puzzle.
      *
      * @param {[[String]]} puzzle: The puzzle to solve
      * @param {[String]} words: The words to solve for
      */
      solve: function(puzzle, words) {

        var solution = wordfind.solve(puzzle, words).found;

        for( var i = 0, len = solution.length; i < len; i++) {
          var word = solution[i].word,
              orientation = solution[i].orientation,
              x = solution[i].x,
              y = solution[i].y,
              next = wordfind.orientations[orientation];

          if (!$('.' + word).hasClass('wordFound')) {
            
            for (var j = 0, size = word.length; j < size; j++) {
              var nextPos = next(x, y, j);
              $('[x="' + nextPos.x + '"][y="' + nextPos.y + '"]').addClass('solved');
            }

            $('.' + word).addClass('wordFound');

          }
        }
        
        $('#solve').addClass('gameSolved'); 

      }
    };
  };


  /**
  * Allow game to be used within the browser
  */
  window.wordfindgame = WordFindGame();

}(document, jQuery, wordfind));

$(function () {
  var words = ['honesty' , 'policy' , 'truthfulness' , 'reward' , 'punish' , 'lie' , 'trust' , 'cause' , 'effect' , 'policy' , 'integrity' , 'fair' , 'cheat' , 'steal' , 'lostandfound'];
  // start a word find game
  var gamePuzzle = wordfindgame.create(
    words, 
    '#puzzle', 
    '#words', 
    { height: 13, 
      width:13, 
      fillBlanks: true
    });
  $('#solve').click( function() {
    wordfindgame.solve(gamePuzzle, words);
  });
  // create just a puzzle, without filling in the blanks and print to console
  var puzzle = wordfind.newPuzzle(
    words, 
    {height: 13, width:13, fillBlanks: true}
  );
  wordfind.print(puzzle);
});
    </script>
</body>
</html>